<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI Background Remover</title>
    <!-- Tailwind CSS CDN -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            font-family: 'Inter', sans-serif;
            margin: 0;
            padding: 0;
            overflow-x: hidden; /* Prevent horizontal scrolling */
        }
        canvas {
            display: block;
            width: 100%;
            height: 100%;
            touch-action: none; /* Disable default touch actions for custom pan/zoom */
        }
        /* Custom scrollbar for better aesthetics */
        ::-webkit-scrollbar {
            width: 8px;
            height: 8px;
        }
        ::-webkit-scrollbar-track {
            background: #f1f1f1;
            border-radius: 10px;
        }
        .dark ::-webkit-scrollbar-track {
            background: #333;
        }
        ::-webkit-scrollbar-thumb {
            background: #888;
            border-radius: 10px;
        }
        .dark ::-webkit-scrollbar-thumb {
            background: #555;
        }
        ::-webkit-scrollbar-thumb:hover {
            background: #555;
        }
        .dark ::-webkit-scrollbar-thumb:hover {
            background: #777;
        }
    </style>
    <!-- Font Awesome for Instagram icon -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css">
</head>
<body class="min-h-screen flex flex-col items-center justify-center p-4 bg-gray-100 text-gray-900 font-inter transition-colors duration-300">

    <!-- Header Credit Bar -->
    <header class="fixed top-0 left-0 right-0 bg-gradient-to-r from-blue-600 to-purple-600 text-white p-3 flex items-center justify-between shadow-lg z-50">
        <div class="flex items-center space-x-2">
            <span class="font-semibold text-lg">Made by Nishikant Xalxo</span>
            <a href="https://www.instagram.com/nishi_vamp" target="_blank" rel="noopener noreferrer" class="text-white hover:text-pink-300 transition-colors duration-200">
                <!-- Instagram icon -->
                <i class="fab fa-instagram text-xl"></i>
            </a>
        </div>
        <button id="darkModeToggle" class="p-2 rounded-full hover:bg-white hover:bg-opacity-20 transition-all duration-200 focus:outline-none focus:ring-2 focus:ring-white" aria-label="Toggle dark mode">
            <!-- Sun Icon (for light mode) / Moon Icon (for dark mode) -->
            <svg id="sunIcon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="hidden"><circle cx="12" cy="12" r="8"/><line x1="12" x2="12" y1="2" y2="6"/><line x1="12" x2="12" y1="18" y2="22"/><line x1="4.22" x2="5.64" y1="4.22" y2="5.64"/><line x1="18.36" x2="19.78" y1="18.36" y2="19.78"/><line x1="2" x2="6" y1="12" y2="12"/><line x1="18" x2="22" y1="12" y2="12"/><line x1="4.22" x2="5.64" y1="19.78" y2="18.36"/><line x1="18.36" x2="19.78" y1="4.22" y2="5.64"/></svg>
            <svg id="moonIcon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M12 3a6 6 0 0 0 9 9 9 9 0 1 1-9-9Z"/></svg>
        </button>
    </header>

    <!-- Main Content Area -->
    <div class="w-full max-w-7xl flex flex-col lg:flex-row gap-6 p-6 rounded-xl shadow-2xl mt-20 bg-white">

        <!-- Left Panel: Upload and Controls -->
        <div class="flex-1 lg:w-1/3 flex flex-col gap-6">
            <!-- Upload Section -->
            <div id="uploadArea" class="border-2 border-dashed border-gray-300 hover:border-blue-400 rounded-xl p-6 text-center transition-colors duration-200 cursor-pointer">
                <input type="file" id="imageUpload" accept="image/jpeg, image/png, image/webp" class="hidden">
                <svg xmlns="http://www.w3.org/2000/svg" width="48" height="48" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="mx-auto mb-3 text-gray-500"><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/><polyline points="17 8 12 3 7 8"/><line x1="12" x2="12" y1="3" y2="15"/></svg>
                <p class="font-semibold text-lg mb-2">Drag & Drop or Click to Upload</p>
                <p class="text-gray-600">JPG, PNG, WEBP up to 50MB</p>
            </div>

            <!-- Controls Section -->
            <div class="p-6 rounded-xl shadow-lg bg-gray-50">
                <h2 class="text-xl font-semibold mb-4">Image Controls</h2>

                <!-- API Key Warning for remove.bg -->
                <div id="removeBgApiWarning" class="bg-red-100 border border-red-400 text-red-700 px-4 py-3 rounded-md mb-4" role="alert">
                    <strong class="font-bold">remove.bg API Key Missing!</strong>
                    <span class="block sm:inline"> Please replace `YOUR_REMOVEBG_API_KEY` in the code with your actual key from remove.bg to enable background removal.</span>
                </div>
                
                <!-- Background Options -->
                <div class="mb-6">
                    <label class="block text-sm font-medium mb-2">Background Type</label>
                    <div class="flex space-x-4 mb-3">
                        <label class="inline-flex items-center">
                            <input type="radio" name="background" value="transparent" checked class="form-radio text-blue-600">
                            <span class="ml-2">Transparent</span>
                        </label>
                        <label class="inline-flex items-center">
                            <input type="radio" name="background" value="color" class="form-radio text-blue-600">
                            <span class="ml-2">Solid Color</span>
                        </label>
                        <label class="inline-flex items-center">
                            <input type="radio" name="background" value="image" class="form-radio text-blue-600">
                            <span class="ml-2">Custom Image</span>
                        </label>
                    </div>
                    <input type="color" id="backgroundColorPicker" value="#ffffff" class="w-full h-10 rounded-lg border-2 border-gray-300 cursor-pointer hidden">
                    <div id="customBgUploadContainer" class="mt-2 hidden">
                        <input type="file" accept="image/jpeg, image/png, image/webp" class="hidden" id="customBgUpload">
                        <label for="customBgUpload" class="w-full inline-flex items-center justify-center px-4 py-2 border border-transparent text-sm font-medium rounded-md shadow-sm bg-blue-500 hover:bg-blue-600 text-white cursor-pointer">
                            Upload Custom Background
                        </label>
                        <p id="customBgSelectedText" class="text-xs text-gray-500 mt-2 hidden">Background image selected.</p>
                    </div>
                </div>

                <!-- Cropping Options -->
                <div class="mb-6">
                    <label class="block text-sm font-medium mb-2">Crop Shape</label>
                    <div class="flex space-x-4 mb-3">
                        <label class="inline-flex items-center">
                            <input type="radio" name="cropShape" value="circle" class="form-radio text-blue-600">
                            <span class="ml-2">Circle</span>
                        </label>
                        <label class="inline-flex items-center">
                            <input type="radio" name="cropShape" value="custom" checked class="form-radio text-blue-600">
                            <span class="ml-2">Custom Ratio</span>
                        </label>
                    </div>
                    <div class="flex gap-2">
                        <input type="number" id="customCropWidth" placeholder="Width" value="800" class="flex-1 p-2 rounded-lg border-gray-300 focus:ring-blue-500 focus:border-blue-500">
                        <span class="self-center">x</span>
                        <input type="number" id="customCropHeight" placeholder="Height" value="600" class="flex-1 p-2 rounded-lg border-gray-300 focus:ring-blue-500 focus:border-blue-500">
                    </div>
                </div>

                <!-- Zoom Slider -->
                <div class="mb-6">
                    <label for="zoomSlider" class="block text-sm font-medium mb-2">Zoom: <span id="zoomLevelDisplay">1.00</span>x</label>
                    <input type="range" id="zoomSlider" min="0.1" max="10" step="0.01" value="1" class="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer range-lg">
                </div>

                <!-- Output Resolution Controls -->
                <div class="mb-6">
                    <h3 class="text-md font-semibold mb-2">Output Resolution</h3>
                    <label for="pixelDensity" class="block text-sm font-medium mb-2">Pixel Density</label>
                    <select id="pixelDensity" class="w-full p-2 rounded-lg border-gray-300 focus:ring-blue-500 focus:border-blue-500">
                        <option value="1x">1x (Standard)</option>
                        <option value="2x">2x (Retina)</option>
                        <option value="3x">3x</option>
                        <option value="4k" selected>4K Output</option>
                    </select>

                    <label for="customDPI" class="block text-sm font-medium mt-4 mb-2">Custom DPI for Print</label>
                    <input type="number" id="customDPI" min="72" max="1200" step="1" value="300" class="w-full p-2 rounded-lg border-gray-300 focus:ring-blue-500 focus:border-blue-500">

                    <label for="outputPreset" class="block text-sm font-medium mt-4 mb-2">Resize Presets</label>
                    <select id="outputPreset" class="w-full p-2 rounded-lg border-gray-300 focus:ring-blue-500 focus:border-blue-500">
                        <option value="none" selected>Original Size</option>
                        <option value="300x400">300x400px</option>
                        <option value="600x800">600x800px</option>
                        <option value="passport">Passport (350x450px)</option>
                    </select>

                    <div id="customOutputDimensions" class="mt-4 hidden">
                        <label class="block text-sm font-medium mb-2">Custom Output Dimensions (px)</label>
                        <div class="flex gap-2">
                            <input type="number" id="customOutputWidth" placeholder="Width" class="flex-1 p-2 rounded-lg border-gray-300 focus:ring-blue-500 focus:border-blue-500">
                            <span class="self-center">x</span>
                            <input type="number" id="customOutputHeight" placeholder="Height" class="flex-1 p-2 rounded-lg border-gray-300 focus:ring-blue-500 focus:border-blue-500">
                        </div>
                    </div>
                </div>

                <!-- Action Buttons -->
                <div class="flex flex-col gap-3 mt-6">
                    <button id="downloadPngBtn" class="w-full flex items-center justify-center px-6 py-3 rounded-md shadow-lg font-semibold transition-all duration-200 bg-blue-600 hover:bg-blue-700 text-white">
                        <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="mr-2"><path d="M15 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V7Z"/><path d="M14 2v4a2 2 0 0 0 2 2h4"/><path d="M10 9H8"/><path d="M16 13H8"/><path d="M16 17H8"/></svg>
                        Download PNG
                    </button>
                    <button id="downloadJpegBtn" class="w-full flex items-center justify-center px-6 py-3 rounded-md shadow-lg font-semibold transition-all duration-200 bg-green-600 hover:bg-green-700 text-white">
                        <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="mr-2"><rect width="18" height="18" x="3" y="3" rx="2" ry="2"/><circle cx="9" cy="9" r="2"/><path d="m21 15-3.086-3.086a2 2 0 0 0-2.828 0L6 21"/></svg>
                        Download JPEG
                    </button>
                    <button id="generateDescriptionBtn" class="w-full flex items-center justify-center px-6 py-3 rounded-md shadow-lg font-semibold transition-all duration-200 bg-purple-600 hover:bg-purple-700 text-white">
                        <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="mr-2"><path d="M21 15a2 2 0 0 1-2 2H7l-4 4V5a2 2 0 0 1 2-2h14a2 2 0 0 1 2 2z"/><path d="M10 8h4"/><path d="M10 12h4"/></svg>
                        Describe Image âœ¨
                    </button>
                    <button id="clearAppBtn" class="w-full flex items-center justify-center px-6 py-3 rounded-md shadow-lg font-semibold transition-all duration-200 bg-red-500 hover:bg-red-600 text-white">
                        <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="mr-2"><path d="M21 12a9 9 0 0 0-9-9 9.75 9.75 0 0 0-6.76 2.74L3 8"/><path d="M3 3v5h5"/><path d="M3 12a9 9 0 0 0 9 9 9.75 9.75 0 0 0 6.76-2.74L21 16"/><path d="M21 21v-5h-5"/></svg>
                        Reset All
                    </button>
                </div>
            </div>
        </div>

        <!-- Right Panel: Preview -->
        <div class="flex-1 lg:w-2/3 flex flex-col gap-6">
            <div class="grid grid-cols-1 md:grid-cols-2 gap-4">
                <!-- Before Preview -->
                <div class="p-4 rounded-xl shadow-lg bg-gray-50">
                    <h3 class="text-lg font-semibold mb-3">Original Image</h3>
                    <div class="w-full h-64 md:h-80 flex items-center justify-center overflow-hidden rounded-lg bg-gray-200">
                        <img id="originalImagePreview" src="" alt="Original" class="max-w-full max-h-full object-contain hidden">
                        <span id="originalImagePlaceholder" class="text-gray-500">Upload an image</span>
                    </div>
                </div>

                <!-- After Preview (Canvas) -->
                <div class="p-4 rounded-xl shadow-lg bg-gray-50">
                    <h3 class="text-lg font-semibold mb-3">Processed Preview</h3>
                    <div class="w-full h-64 md:h-80 flex items-center justify-center overflow-hidden rounded-lg relative bg-white">
                        <canvas id="mainCanvas" class="w-full h-full object-contain cursor-grab" style="touch-action: none;"></canvas>
                        <span id="processedImagePlaceholder" class="text-gray-500 absolute top-1/2 left-1/2 -translate-x-1/2 -translate-y-1/2">Processed image will appear here</span>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Toast Notification Container -->
    <div id="toastContainer" class="fixed bottom-4 right-4 p-4 rounded-lg shadow-xl text-white z-[1000] hidden"></div>

    <!-- Image Description Modal -->
    <div id="descriptionModal" class="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-[1100] hidden">
        <div class="p-6 rounded-lg shadow-xl bg-white w-11/12 md:w-1/2 max-w-lg">
            <div class="flex justify-between items-center mb-4">
                <h3 class="text-xl font-semibold">Image Description</h3>
                <button id="closeDescriptionModal" class="text-gray-400 hover:text-gray-600">
                    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-x"><path d="M18 6 6 18"/><path d="m6 6 12 12"/></svg>
                </button>
            </div>
            <p id="generatedDescriptionText" class="text-lg mb-4"></p>
            <button id="closeDescriptionModalBtn" class="px-4 py-2 rounded-md font-semibold bg-blue-500 hover:bg-blue-600 text-white">
                Close
            </button>
        </div>
    </div>

    <script>
        // --- DOM Elements ---
        const imageUpload = document.getElementById('imageUpload');
        const uploadArea = document.getElementById('uploadArea');
        const originalImagePreview = document.getElementById('originalImagePreview');
        const originalImagePlaceholder = document.getElementById('originalImagePlaceholder');
        const mainCanvas = document.getElementById('mainCanvas');
        const processedImagePlaceholder = document.getElementById('processedImagePlaceholder');
        const zoomSlider = document.getElementById('zoomSlider');
        const zoomLevelDisplay = document.getElementById('zoomLevelDisplay');
        const backgroundColorPicker = document.getElementById('backgroundColorPicker');
        const customBgUpload = document.getElementById('customBgUpload');
        const customBgUploadContainer = document.getElementById('customBgUploadContainer');
        const customBgSelectedText = document.getElementById('customBgSelectedText');
        const customCropWidthInput = document.getElementById('customCropWidth');
        const customCropHeightInput = document.getElementById('customCropHeight');
        const pixelDensitySelect = document.getElementById('pixelDensity');
        const customDPIInput = document.getElementById('customDPI');
        const outputPresetSelect = document.getElementById('outputPreset');
        const customOutputDimensionsDiv = document.getElementById('customOutputDimensions');
        const customOutputWidthInput = document.getElementById('customOutputWidth');
        const customOutputHeightInput = document.getElementById('customOutputHeight');
        const downloadPngBtn = document.getElementById('downloadPngBtn');
        const downloadJpegBtn = document.getElementById('downloadJpegBtn');
        const generateDescriptionBtn = document.getElementById('generateDescriptionBtn');
        const clearAppBtn = document.getElementById('clearAppBtn');
        const toastContainer = document.getElementById('toastContainer');
        const descriptionModal = document.getElementById('descriptionModal');
        const generatedDescriptionText = document.getElementById('generatedDescriptionText');
        const closeDescriptionModal = document.getElementById('closeDescriptionModal');
        const closeDescriptionModalBtn = document.getElementById('closeDescriptionModalBtn');
        const darkModeToggle = document.getElementById('darkModeToggle');
        const sunIcon = document.getElementById('sunIcon');
        const moonIcon = document.getElementById('moonIcon');
        const removeBgApiWarning = document.getElementById('removeBgApiWarning');

        const ctx = mainCanvas.getContext('2d');
        const imageRef = new Image(); // Hidden image element for original/processed image

        // --- State Variables (Vanilla JS equivalent of React useState) ---
        let originalImage = null; // Data URL of original uploaded image
        let processedImage = null; // Data URL of background-removed image
        let isLoading = false; // Loading state for general operations (download, etc.)
        let backgroundType = 'transparent'; // 'transparent', 'color', 'image'
        let backgroundColor = '#ffffff'; // Default white
        let customBackgroundFile = null; // File object for custom background
        let customBackgroundDataUrl = null; // Data URL for custom background
        let zoomLevel = 1; // Zoom for the canvas preview
        let pan = { x: 0, y: 0 }; // Pan for the canvas preview
        let isPanning = false;
        let startPan = { x: 0, y: 0 };
        let cropShape = 'custom'; // Always 'custom' now, or 'circle' if selected
        let customCropWidth = 800; // Default custom width (e.g., for 4:3)
        let customCropHeight = 600; // Default custom height (e.g., for 4:3)
        let generatedDescription = '';
        let darkMode = false;

        // API Key for remove.bg (IMPORTANT: Replace with your actual key for functionality)
        const REMOVEBG_API_KEY = "bNDVjQhJJA1R2zi22A5fhzN2"; // Your provided key

        // --- Utility Functions ---

        function showToast(message, type = 'info') {
            toastContainer.textContent = message;
            toastContainer.className = `fixed bottom-4 right-4 p-4 rounded-lg shadow-xl text-white z-[1000]`;
            if (type === 'success') toastContainer.classList.add('bg-green-500');
            else if (type === 'error') toastContainer.classList.add('bg-red-500');
            else toastContainer.classList.add('bg-gray-800');
            toastContainer.classList.remove('hidden');
            setTimeout(() => {
                toastContainer.classList.add('hidden');
            }, 3000);
        }

        function updateLoadingState(loading) {
            isLoading = loading;
            const buttons = [downloadPngBtn, downloadJpegBtn, generateDescriptionBtn];
            buttons.forEach(btn => {
                if (loading) {
                    btn.classList.add('bg-gray-400', 'cursor-not-allowed');
                    btn.classList.remove('bg-blue-600', 'hover:bg-blue-700', 'bg-green-600', 'hover:bg-green-700', 'bg-purple-600', 'hover:bg-purple-700');
                    // Add spinner if needed, but for simplicity, just disable
                } else {
                    btn.classList.remove('bg-gray-400', 'cursor-not-allowed');
                    if (btn === downloadPngBtn) btn.classList.add('bg-blue-600', 'hover:bg-blue-700');
                    else if (btn === downloadJpegBtn) btn.classList.add('bg-green-600', 'hover:bg-green-700');
                    else if (btn === generateDescriptionBtn) btn.classList.add('bg-purple-600', 'hover:bg-purple-700');
                }
            });
        }

        function clearApp() {
            originalImage = null;
            processedImage = null;
            imageRef.src = '';
            originalImagePreview.src = '';
            originalImagePreview.classList.add('hidden');
            originalImagePlaceholder.classList.remove('hidden');
            mainCanvas.width = 0; // Clear canvas
            mainCanvas.height = 0;
            processedImagePlaceholder.classList.remove('hidden');

            zoomLevel = 1;
            zoomSlider.value = 1;
            zoomLevelDisplay.textContent = '1.00';
            pan = { x: 0, y: 0 };

            backgroundType = 'transparent';
            document.querySelector('input[name="background"][value="transparent"]').checked = true;
            backgroundColor = '#ffffff';
            backgroundColorPicker.value = '#ffffff';
            backgroundColorPicker.classList.add('hidden');
            customBackgroundFile = null;
            customBackgroundDataUrl = null;
            customBgUploadContainer.classList.add('hidden');
            customBgSelectedText.classList.add('hidden');

            cropShape = 'custom';
            document.querySelector('input[name="cropShape"][value="custom"]').checked = true;
            customCropWidth = 800;
            customCropHeight = 600;
            customCropWidthInput.value = 800;
            customCropHeightInput.value = 600;

            pixelDensitySelect.value = '4k';
            customDPIInput.value = 300;
            outputPresetSelect.value = 'none';
            customOutputWidth = '';
            customOutputHeight = '';
            customOutputWidthInput.value = '';
            customOutputHeightInput.value = '';
            customOutputDimensionsDiv.classList.add('hidden');

            generatedDescription = '';
            descriptionModal.classList.add('hidden');
            showToast('App cleared!', 'info');
            drawCanvas(); // Redraw canvas to clear it fully
        }

        // --- Image Upload & Processing ---

        async function handleImageUpload(file) {
            if (!file) return;

            if (file.size > 50 * 1024 * 1024) {
                showToast('File size exceeds 50MB limit. Please upload a smaller image.', 'error');
                return;
            }

            if (!['image/jpeg', 'image/png', 'image/webp'].includes(file.type)) {
                showToast('Invalid file type. Please upload JPG, PNG, or WEBP.', 'error');
                return;
            }

            const reader = new FileReader();
            reader.onloadend = () => {
                originalImage = reader.result;
                originalImagePreview.src = originalImage;
                originalImagePreview.classList.remove('hidden');
                originalImagePlaceholder.classList.add('hidden');

                imageRef.onload = () => {
                    zoomLevel = 1;
                    zoomSlider.value = 1;
                    zoomLevelDisplay.textContent = '1.00';
                    pan = { x: 0, y: 0 };
                    processedImagePlaceholder.classList.add('hidden'); // Hide placeholder once processed image is ready
                    drawCanvas();
                };
                imageRef.src = originalImage; // This triggers imageRef.onload
                removeBackground(originalImage);
            };
            reader.readAsDataURL(file);
        }

        async function removeBackground(imageDataUrl) {
            updateLoadingState(true);
            showToast('Removing background...', 'info');

            try {
                if (REMOVEBG_API_KEY === "bNDVjQhJJA1R2zi22A5fhzN2") {
                    // This warning is now conditional based on the actual key
                    // If the user's key is the placeholder, this message will still show.
                    // If the user provides a real key, this block is skipped.
                }
                // Always hide warning if key is present, regardless of what it is.
                // The warning is meant for the *initial* state if user hasn't put their key.
                removeBgApiWarning.classList.add('hidden'); 

                const response = await fetch(imageDataUrl);
                const blob = await response.blob();

                const formData = new FormData();
                formData.append('image_file', blob, 'image.png');
                formData.append('size', 'auto');
                formData.append('format', 'png');

                const apiResponse = await fetch('https://api.remove.bg/v1.0/removebg', {
                    method: 'POST',
                    headers: {
                        'X-Api-Key': REMOVEBG_API_KEY
                    },
                    body: formData
                });

                if (!apiResponse.ok) {
                    const errorText = await apiResponse.text();
                    throw new Error(`remove.bg API Error: ${apiResponse.status} - ${errorText}. Please check your API key and account limits.`);
                }

                const resultBlob = await apiResponse.blob();
                const reader = new FileReader();
                reader.onloadend = () => {
                    processedImage = reader.result;
                    imageRef.src = processedImage; // Update imageRef for canvas
                    showToast('Background removed successfully!', 'success');
                    drawCanvas(); // Redraw canvas with new processed image
                };
                reader.readAsDataURL(resultBlob);

            } catch (error) {
                console.error('Background removal failed:', error);
                showToast(`Background removal failed: ${error.message}`, 'error');
                processedImage = originalImage; // Fallback to original if removal fails
                imageRef.src = processedImage; // Update imageRef to show original
                drawCanvas();
            } finally {
                updateLoadingState(false);
            }
        }

        function handleCustomBackgroundUpload(event) {
            const file = event.target.files[0];
            if (file) {
                if (!['image/jpeg', 'image/png', 'image/webp'].includes(file.type)) {
                    showToast('Invalid file type for background. Please upload JPG, PNG, or WEBP.', 'error');
                    return;
                }
                const reader = new FileReader();
                reader.onloadend = () => {
                    customBackgroundDataUrl = reader.result;
                    backgroundType = 'image';
                    document.querySelector('input[name="background"][value="image"]').checked = true;
                    showToast('Custom background uploaded!', 'info');
                    customBgSelectedText.classList.remove('hidden');
                    drawCanvas();
                };
                reader.readAsDataURL(file);
                customBackgroundFile = file;
            }
        }

        // --- Canvas Drawing Logic ---

        function drawCanvas() {
            if (!mainCanvas || !imageRef.src) return;

            const image = imageRef;

            const imageWidth = image.naturalWidth;
            const imageHeight = image.naturalHeight;

            // Calculate canvas size to fit container, maintaining aspect ratio for preview
            const containerWidth = mainCanvas.parentNode.clientWidth;
            const containerHeight = mainCanvas.parentNode.clientHeight;
            const canvasRatio = containerWidth / containerHeight;
            const imageRatio = imageWidth / imageHeight;

            let displayWidth, displayHeight;
            if (imageRatio > canvasRatio) {
                displayWidth = containerWidth;
                displayHeight = containerWidth / imageRatio;
            } else {
                displayHeight = containerHeight;
                displayWidth = containerHeight * imageRatio;
            }

            mainCanvas.width = displayWidth;
            mainCanvas.height = displayHeight;

            ctx.clearRect(0, 0, mainCanvas.width, mainCanvas.height);

            // Apply background first
            if (backgroundType === 'color') {
                ctx.fillStyle = backgroundColor;
                ctx.fillRect(0, 0, mainCanvas.width, mainCanvas.height);
            } else if (backgroundType === 'image' && customBackgroundDataUrl) {
                const bgImage = new Image();
                bgImage.src = customBackgroundDataUrl;
                bgImage.onload = () => {
                    const bgRatio = bgImage.naturalWidth / bgImage.naturalHeight;
                    let dx = 0, dy = 0, dWidth = mainCanvas.width, dHeight = mainCanvas.height;

                    if (bgRatio > mainCanvas.width / mainCanvas.height) {
                        dHeight = mainCanvas.height;
                        dWidth = dHeight * bgRatio;
                        dx = (mainCanvas.width - dWidth) / 2;
                    } else {
                        dWidth = mainCanvas.width;
                        dHeight = dWidth / bgRatio;
                        dy = (mainCanvas.height - dHeight) / 2;
                    }
                    ctx.drawImage(bgImage, dx, dy, dWidth, dHeight);
                    drawForegroundImage();
                };
                if (!bgImage.complete) return;
            } else { // Transparent checkerboard
                const patternSize = 20;
                for (let x = 0; x < mainCanvas.width; x += patternSize) {
                    for (let y = 0; y < mainCanvas.height; y += patternSize) {
                        ctx.fillStyle = (Math.floor(x / patternSize) + Math.floor(y / patternSize)) % 2 === 0 ? '#f0f0f0' : '#e0e0e0';
                        ctx.fillRect(x, y, patternSize, patternSize);
                    }
                }
            }

            const drawForegroundImage = () => {
                const scaledWidth = imageWidth * zoomLevel;
                const scaledHeight = imageHeight * zoomLevel;
                const offsetX = (mainCanvas.width - scaledWidth) / 2 + pan.x;
                const offsetY = (mainCanvas.height - scaledHeight) / 2 + pan.y;

                ctx.save();

                if (cropShape === 'circle') {
                    const radius = Math.min(scaledWidth, scaledHeight) / 2;
                    const centerX = offsetX + scaledWidth / 2;
                    const centerY = offsetY + scaledHeight / 2;
                    ctx.beginPath();
                    ctx.arc(centerX, centerY, radius, 0, Math.PI * 2, true);
                    ctx.closePath();
                    ctx.clip();
                } else { // 'custom' crop shape
                    const effectiveCropWidth = parseFloat(customCropWidth);
                    const effectiveCropHeight = parseFloat(customCropHeight);
                    
                    if (effectiveCropWidth && effectiveCropHeight) {
                        const cropRatio = effectiveCropWidth / effectiveCropHeight;
                        const currentCanvasDisplayRatio = mainCanvas.width / mainCanvas.height;
                        let cropRectWidth, cropRectHeight;
                        if (cropRatio > currentCanvasDisplayRatio) {
                            cropRectWidth = mainCanvas.width;
                            cropRectHeight = mainCanvas.width / cropRatio;
                        } else {
                            cropRectHeight = mainCanvas.height;
                            cropRectWidth = mainCanvas.height * cropRatio;
                        }
                        
                        const cropRectX = (mainCanvas.width - cropRectWidth) / 2;
                        const cropRectY = (mainCanvas.height - cropRectHeight) / 2;

                        ctx.beginPath();
                        ctx.rect(cropRectX, cropRectY, cropRectWidth, cropRectHeight);
                        ctx.clip();
                    }
                }

                ctx.drawImage(image, offsetX, offsetY, scaledWidth, scaledHeight);
                ctx.restore();

                // DRAW VISUAL CROPPING INDICATOR (Yellow Dashed Rectangle/Circle)
                if (customCropWidth && customCropHeight) {
                    const cropRatio = parseFloat(customCropWidth) / parseFloat(customCropHeight);
                    let indicatorWidth, indicatorHeight;

                    const currentCanvasDisplayRatio = mainCanvas.width / mainCanvas.height;
                    if (cropRatio > currentCanvasDisplayRatio) {
                        indicatorWidth = mainCanvas.width * 0.9;
                        indicatorHeight = indicatorWidth / cropRatio;
                    } else {
                        indicatorHeight = mainCanvas.height * 0.9;
                        indicatorWidth = indicatorHeight * cropRatio;
                    }

                    const indicatorX = (mainCanvas.width - indicatorWidth) / 2;
                    const indicatorY = (mainCanvas.height - indicatorHeight) / 2;

                    ctx.strokeStyle = 'rgba(255, 255, 0, 0.8)';
                    ctx.lineWidth = 2;
                    ctx.setLineDash([8, 8]);
                    
                    if (cropShape === 'circle') {
                        const radius = Math.min(indicatorWidth, indicatorHeight) / 2;
                        ctx.beginPath();
                        ctx.arc(mainCanvas.width / 2, mainCanvas.height / 2, radius, 0, Math.PI * 2, true);
                        ctx.stroke();
                    } else {
                        ctx.strokeRect(indicatorX, indicatorY, indicatorWidth, indicatorHeight);
                    }
                    
                    ctx.setLineDash([]);
                }
            };

            drawForegroundImage();
        }

        // --- Canvas Interaction Handlers (Pan & Zoom) ---

        function handleMouseDown(e) {
            isPanning = true;
            startPan = { x: e.clientX, y: e.clientY };
            mainCanvas.style.cursor = 'grabbing';
        }

        function handleMouseMove(e) {
            if (!isPanning) return;
            const dx = e.clientX - startPan.x;
            const dy = e.clientY - startPan.y;
            pan = { x: pan.x + dx, y: pan.y + dy };
            startPan = { x: e.clientX, y: e.clientY };
            drawCanvas();
        }

        function handleMouseUp() {
            isPanning = false;
            mainCanvas.style.cursor = 'grab';
        }

        function handleMouseLeave() {
            isPanning = false;
            mainCanvas.style.cursor = 'grab';
        }

        function handleWheel(e) {
            e.preventDefault();
            const scaleFactor = 1.1;
            const newZoom = e.deltaY < 0 ? zoomLevel * scaleFactor : zoomLevel / scaleFactor;
            zoomLevel = Math.max(0.1, Math.min(10, newZoom));
            zoomSlider.value = zoomLevel;
            zoomLevelDisplay.textContent = zoomLevel.toFixed(2);
            drawCanvas();
        }

        // --- Download Logic ---

        async function renderFinalImageToBlob(format = 'png') {
            const sourceImage = processedImage || originalImage;

            if (!sourceImage) {
                showToast('No image loaded to render!', 'error');
                return null;
            }

            const tempImage = new Image();
            tempImage.src = sourceImage;
            await new Promise(resolve => tempImage.onload = resolve);

            const originalWidth = tempImage.naturalWidth;
            const originalHeight = tempImage.naturalHeight;

            let targetWidth, targetHeight;

            if (outputPresetSelect.value !== 'none') {
                switch (outputPresetSelect.value) {
                    case '300x400': targetWidth = 300; targetHeight = 400; break;
                    case '600x800': targetWidth = 600; targetHeight = 800; break;
                    case 'passport': targetWidth = 350; targetHeight = 450; break;
                    default: targetWidth = originalWidth; targetHeight = originalHeight;
                }
            } else if (customOutputWidthInput.value && customOutputHeightInput.value) {
                targetWidth = parseInt(customOutputWidthInput.value);
                targetHeight = parseInt(customOutputHeightInput.value);
            } else {
                const pixelsPerMM = parseFloat(customDPIInput.value) / 25.4;
                let baseTargetWidth = 210 * pixelsPerMM;
                let baseTargetHeight = 297 * pixelsPerMM;

                const sourceAspectRatio = originalWidth / originalHeight;
                if (baseTargetWidth / baseTargetHeight > sourceAspectRatio) {
                    baseTargetWidth = baseTargetHeight * sourceAspectRatio;
                } else {
                    baseTargetHeight = baseTargetWidth / sourceAspectRatio;
                }

                targetWidth = baseTargetWidth;
                targetHeight = baseTargetHeight;

                let densityFactor = 1;
                if (pixelDensitySelect.value === '2x') densityFactor = 2;
                if (pixelDensitySelect.value === '3x') densityFactor = 3;
                if (pixelDensitySelect.value === '4k') {
                    const min4kWidth = 3840;
                    const min4kHeight = 2160;
                    if (targetWidth < min4kWidth || targetHeight < min4kHeight) {
                        if (sourceAspectRatio > (min4kWidth / min4kHeight)) {
                            targetWidth = min4kWidth;
                            targetHeight = min4kWidth / sourceAspectRatio;
                        } else {
                            targetHeight = min4kHeight;
                            targetWidth = min4kHeight * sourceAspectRatio;
                        }
                    }
                }
                targetWidth *= densityFactor;
                targetHeight *= densityFactor;
            }

            const offscreenCanvas = document.createElement('canvas');
            const offscreenCtx = offscreenCanvas.getContext('2d');

            offscreenCanvas.width = targetWidth;
            offscreenCanvas.height = targetHeight;

            if (backgroundType === 'color') {
                offscreenCtx.fillStyle = backgroundColor;
                offscreenCtx.fillRect(0, 0, offscreenCanvas.width, offscreenCanvas.height);
            } else if (backgroundType === 'image' && customBackgroundDataUrl) {
                const bgImage = new Image();
                bgImage.src = customBackgroundDataUrl;
                await new Promise(resolve => bgImage.onload = resolve);
                offscreenCtx.drawImage(bgImage, 0, 0, offscreenCanvas.width, offscreenCanvas.height);
            }

            const image = tempImage; 
            const imgW = image.naturalWidth;
            const imgH = image.naturalHeight;

            const previewCanvasWidth = mainCanvas.width;
            const previewCanvasHeight = mainCanvas.height;

            const displayedImageWidthOnPreview = imgW * zoomLevel;
            const displayedImageHeightOnPreview = imgH * zoomLevel;

            const displayedImageXOnPreview = (previewCanvasWidth - displayedImageWidthOnPreview) / 2 + pan.x;
            const displayedImageYOnPreview = (previewCanvasHeight - displayedImageHeightOnPreview) / 2 + pan.y;
            
            let sx, sy, sWidth, sHeight;

            const currentCropRatio = parseFloat(customCropWidth) / parseFloat(customCropHeight);
            
            let effectivePreviewCropWidth, effectivePreviewCropHeight;
            const currentPreviewRatio = previewCanvasWidth / previewCanvasHeight;

            if (currentCropRatio > currentPreviewRatio) {
              effectivePreviewCropWidth = previewCanvasWidth;
              effectivePreviewCropHeight = previewCanvasWidth / currentCropRatio;
            } else {
              effectivePreviewCropHeight = previewCanvasHeight;
              effectivePreviewCropWidth = previewCanvasHeight * currentCropRatio;
            }

            const effectivePreviewCropX = (previewCanvasWidth - effectivePreviewCropWidth) / 2;
            const effectivePreviewCropY = (previewCanvasHeight - effectivePreviewCropHeight) / 2;

            const imageOffsetXInCrop = displayedImageXOnPreview - effectivePreviewCropX;
            const imageOffsetYInCrop = displayedImageYOnPreview - effectivePreviewCropY;

            sx = Math.max(0, -imageOffsetXInCrop / zoomLevel);
            sy = Math.max(0, -imageOffsetYInCrop / zoomLevel);
            
            sWidth = effectivePreviewCropWidth / zoomLevel;
            sHeight = effectivePreviewCropHeight / zoomLevel;

            sWidth = Math.min(sWidth, imgW - sx);
            sHeight = Math.min(sHeight, imgH - sy);

            sWidth = Math.max(0, sWidth);
            sHeight = Math.max(0, sHeight);

            const sourceRegionAspectRatio = sWidth / sHeight;

            offscreenCtx.save();

            let finalDrawX = 0, finalDrawY = 0, finalDrawWidth = offscreenCanvas.width, finalDrawHeight = offscreenCanvas.height;

            if (cropShape === 'circle') {
                const radius = Math.min(offscreenCanvas.width, offscreenCanvas.height) / 2;
                offscreenCtx.beginPath();
                offscreenCtx.arc(offscreenCanvas.width / 2, offscreenCanvas.height / 2, radius, 0, Math.PI * 2, true);
                offscreenCtx.closePath();
                offscreenCtx.clip();

                const circleDiameter = radius * 2;
                if (sourceRegionAspectRatio > 1) {
                    finalDrawWidth = circleDiameter;
                    finalDrawHeight = circleDiameter / sourceRegionAspectRatio;
                } else {
                    finalDrawHeight = circleDiameter;
                    finalDrawWidth = circleDiameter * sourceRegionAspectRatio;
                }
                finalDrawX = (offscreenCanvas.width - finalDrawWidth) / 2;
                finalDrawY = (offscreenCanvas.height - finalDrawHeight) / 2;

            } else { // 'custom' crop shape
                const effectiveOutputWidth = parseFloat(customOutputWidthInput.value || targetWidth);
                const effectiveOutputHeight = parseFloat(customOutputHeightInput.value || targetHeight);
                
                const desiredOutputRatio = effectiveOutputWidth / effectiveOutputHeight;
                
                let clipRectWidth, clipRectHeight;

                if (desiredOutputRatio > (offscreenCanvas.width / offscreenCanvas.height)) {
                    clipRectWidth = offscreenCanvas.width;
                    clipRectHeight = offscreenCanvas.width / desiredOutputRatio;
                } else {
                    clipRectHeight = offscreenCanvas.height;
                    clipRectWidth = offscreenCanvas.height * desiredOutputRatio;
                }

                const clipRectX = (offscreenCanvas.width - clipRectWidth) / 2;
                const clipRectY = (offscreenCanvas.height - clipRectHeight) / 2;

                offscreenCtx.beginPath();
                offscreenCtx.rect(clipRectX, clipRectY, clipRectWidth, clipRectHeight);
                offscreenCtx.clip();

                const clippedAreaAspectRatio = clipRectWidth / clipRectHeight;
                if (sourceRegionAspectRatio > clippedAreaAspectRatio) {
                    finalDrawHeight = clipRectWidth / sourceRegionAspectRatio;
                    finalDrawWidth = clipRectWidth;
                    finalDrawY = clipRectY + (clipRectHeight - finalDrawHeight) / 2;
                    finalDrawX = clipRectX;
                } else {
                    finalDrawWidth = clipRectHeight * sourceRegionAspectRatio;
                    finalDrawHeight = clipRectHeight;
                    finalDrawX = clipRectX + (clipRectWidth - finalDrawWidth) / 2;
                    finalDrawY = clipRectY;
                }
            }

            offscreenCtx.drawImage(image, sx, sy, sWidth, sHeight, finalDrawX, finalDrawY, finalDrawWidth, finalDrawHeight);
            offscreenCtx.restore();

            return new Promise(resolve => {
              offscreenCanvas.toBlob(resolve, `image/${format}`, 1.0); // Set quality to 1.0 for both PNG and JPEG
            });
        }

        async function downloadImage(format) {
            updateLoadingState(true);
            showToast(`Preparing ${format.toUpperCase()} for download...`, 'info');
            try {
                const blob = await renderFinalImageToBlob(format);
                if (blob) {
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = `edited_image.${format}`;
                    document.body.appendChild(a);
                    a.click();
                    document.body.removeChild(a);
                    URL.revokeObjectURL(url);
                    showToast(`Image downloaded as ${format.toUpperCase()}!`, 'success');
                }
            } catch (error) {
                console.error('Download failed:', error);
                showToast(`Failed to download image: ${error.message}`, 'error');
            } finally {
                updateLoadingState(false);
            }
        }

        // --- LLM Functions ---

        function blobToBase64(blob) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onloadend = () => {
                    resolve(reader.result.split(',')[1]);
                };
                reader.onerror = reject;
                reader.readAsDataURL(blob);
            });
        }

        async function handleGenerateDescription() {
            if (!processedImage) {
                showToast('Please upload and process an image first!', 'error');
                return;
            }
            if (REMOVEBG_API_KEY === "bNDVjQhJJA1R2zi22A5fhzN2") {
                showToast('Please set your remove.bg API key to enable this feature.', 'error');
                return;
            }

            updateLoadingState(true); // Re-using isLoading for this too
            showToast('Generating description with AI...', 'info');
            generatedDescriptionText.textContent = ''; // Clear previous description

            try {
                const finalImageBlob = await renderFinalImageToBlob('png');
                if (!finalImageBlob) {
                    throw new Error('Failed to render final image for description.');
                }
                const base64ImageData = await blobToBase64(finalImageBlob);

                const promptText = "Describe the main subject in this image concisely for an alt text or a short caption. Focus on the main object, its pose/expression, and key characteristics. Do not mention the background as it has been removed or replaced. Keep it under 2 sentences and suitable for visual impairment assistance.";

                let chatHistory = [];
                chatHistory.push({
                    role: "user",
                    parts: [
                        { text: promptText },
                        { inlineData: { mimeType: "image/png", data: base64ImageData } }
                    ]
                });

                const payload = { contents: chatHistory };
                const apiKey = ""; // Canvas will automatically provide the API key at runtime
                const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=${apiKey}`;

                const response = await fetch(apiUrl, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });

                if (!response.ok) {
                    const errorData = await response.json();
                    throw new Error(`Gemini API Error: ${response.status} - ${errorData.error?.message || response.statusText}`);
                }

                const result = await response.json();
                if (result.candidates && result.candidates.length > 0 &&
                    result.candidates[0].content && result.candidates[0].content.parts &&
                    result.candidates[0].content.parts.length > 0) {
                    generatedDescription = result.candidates[0].content.parts[0].text;
                    generatedDescriptionText.textContent = generatedDescription;
                    descriptionModal.classList.remove('hidden');
                    showToast('Image description generated!', 'success');
                } else {
                    throw new Error('No content received from Gemini API.');
                }

            } catch (error) {
                console.error("Image description generation failed:", error);
                generatedDescriptionText.textContent = `Error: ${error.message}`;
                descriptionModal.classList.remove('hidden');
                showToast(`Description generation failed: ${error.message}`, 'error');
            } finally {
                updateLoadingState(false);
            }
        }

        // --- Event Listeners ---

        // Dark Mode Toggle
        darkModeToggle.addEventListener('click', () => {
            darkMode = !darkMode;
            document.documentElement.classList.toggle('dark', darkMode);
            document.body.classList.toggle('bg-gray-900', darkMode);
            document.body.classList.toggle('text-gray-100', darkMode);
            document.body.classList.toggle('bg-gray-100', !darkMode);
            document.body.classList.toggle('text-gray-900', !darkMode);

            // Update header and main content background for dark mode
            document.querySelector('.w-full.max-w-7xl').classList.toggle('bg-gray-800', darkMode);
            document.querySelector('.w-full.max-w-7xl').classList.toggle('bg-white', !darkMode);

            // Update inner panel backgrounds
            document.querySelectorAll('.p-6.rounded-xl.shadow-lg').forEach(panel => {
                panel.classList.toggle('bg-gray-700', darkMode);
                panel.classList.toggle('bg-gray-50', !darkMode);
            });
            document.querySelectorAll('.rounded-lg.bg-gray-200, .rounded-lg.bg-white').forEach(div => {
                div.classList.toggle('bg-gray-600', darkMode); // for original image preview bg
                div.classList.toggle('bg-gray-800', darkMode); // for processed image preview bg
                div.classList.toggle('bg-gray-200', !darkMode);
                div.classList.toggle('bg-white', !darkMode);
            });
             document.querySelectorAll('.text-gray-500').forEach(span => {
                span.classList.toggle('text-gray-400', darkMode);
                span.classList.toggle('text-gray-500', !darkMode);
            });
             document.querySelectorAll('.border-gray-300').forEach(input => {
                input.classList.toggle('border-gray-600', darkMode);
                input.classList.toggle('border-gray-300', !darkMode);
                input.classList.toggle('bg-gray-800', darkMode);
                input.classList.toggle('bg-white', !darkMode);
            });
             document.querySelectorAll('.bg-gray-200').forEach(slider => {
                slider.classList.toggle('bg-gray-700', darkMode);
                slider.classList.toggle('bg-gray-200', !darkMode);
            });
             document.querySelectorAll('.hover\\:border-blue-400').forEach(el => {
                el.classList.toggle('hover:border-blue-500', darkMode);
                el.classList.toggle('hover:border-blue-400', !darkMode);
            });

            // Update icons
            sunIcon.classList.toggle('hidden', !darkMode);
            moonIcon.classList.toggle('hidden', darkMode);
            localStorage.setItem('darkMode', darkMode);
            showToast(darkMode ? 'Dark mode enabled!' : 'Light mode enabled!', 'info');
        });

        // Initialize dark mode from localStorage
        window.addEventListener('DOMContentLoaded', () => {
            const savedDarkMode = localStorage.getItem('darkMode') === 'true';
            if (savedDarkMode) {
                darkMode = true;
                document.documentElement.classList.add('dark');
                document.body.classList.add('bg-gray-900', 'text-gray-100');
                document.querySelector('.w-full.max-w-7xl').classList.add('bg-gray-800');
                document.querySelectorAll('.p-6.rounded-xl.shadow-lg').forEach(panel => panel.classList.add('bg-gray-700'));
                document.querySelectorAll('.rounded-lg.bg-gray-200, .rounded-lg.bg-white').forEach(div => {
                  div.classList.add('bg-gray-600');
                  div.classList.add('bg-gray-800');
                });
                document.querySelectorAll('.text-gray-500').forEach(span => span.classList.add('text-gray-400'));
                document.querySelectorAll('.border-gray-300').forEach(input => {
                    input.classList.add('border-gray-600');
                    input.classList.add('bg-gray-800');
                });
                document.querySelectorAll('.bg-gray-200').forEach(slider => slider.classList.add('bg-gray-700'));
                document.querySelectorAll('.hover\\:border-blue-400').forEach(el => el.classList.add('hover:border-blue-500'));
                sunIcon.classList.remove('hidden');
                moonIcon.classList.add('hidden');
            } else {
                sunIcon.classList.add('hidden');
                moonIcon.classList.remove('hidden');
            }

            // Check if API key is set for remove.bg warning
            if (REMOVEBG_API_KEY !== "bNDVjQhJJA1R2zi22A5fhzN2") {
                removeBgApiWarning.classList.add('hidden');
            } else {
                removeBgApiWarning.classList.remove('hidden'); // Ensure warning is visible if key is default placeholder
            }
        });


        // Image Upload
        uploadArea.addEventListener('click', () => imageUpload.click());
        imageUpload.addEventListener('change', (e) => handleImageUpload(e.target.files[0]));
        uploadArea.addEventListener('dragover', (e) => e.preventDefault());
        uploadArea.addEventListener('drop', (e) => {
            e.preventDefault();
            handleImageUpload(e.dataTransfer.files[0]);
        });

        // Background Type Selection
        document.querySelectorAll('input[name="background"]').forEach(radio => {
            radio.addEventListener('change', (e) => {
                backgroundType = e.target.value;
                if (backgroundType === 'color') {
                    backgroundColorPicker.classList.remove('hidden');
                    customBgUploadContainer.classList.add('hidden');
                    customBgSelectedText.classList.add('hidden');
                } else if (backgroundType === 'image') {
                    customBgUploadContainer.classList.remove('hidden');
                    backgroundColorPicker.classList.add('hidden');
                    if (customBackgroundDataUrl) customBgSelectedText.classList.remove('hidden');
                    else customBgSelectedText.classList.add('hidden');
                } else { // transparent
                    backgroundColorPicker.classList.add('hidden');
                    customBgUploadContainer.classList.add('hidden');
                    customBgSelectedText.classList.add('hidden');
                }
                drawCanvas();
            });
        });
        backgroundColorPicker.addEventListener('input', (e) => {
            backgroundColor = e.target.value;
            drawCanvas();
        });
        customBgUpload.addEventListener('change', handleCustomBackgroundUpload);

        // Crop Shape Selection
        document.querySelectorAll('input[name="cropShape"]').forEach(radio => {
            radio.addEventListener('change', (e) => {
                cropShape = e.target.value;
                drawCanvas();
            });
        });
        customCropWidthInput.addEventListener('input', drawCanvas);
        customCropHeightInput.addEventListener('input', drawCanvas);

        // Zoom Slider
        zoomSlider.addEventListener('input', (e) => {
            zoomLevel = parseFloat(e.target.value);
            zoomLevelDisplay.textContent = zoomLevel.toFixed(2);
            drawCanvas();
        });

        // Canvas Pan/Zoom
        mainCanvas.addEventListener('mousedown', handleMouseDown);
        mainCanvas.addEventListener('mousemove', handleMouseMove);
        mainCanvas.addEventListener('mouseup', handleMouseUp);
        mainCanvas.addEventListener('mouseleave', handleMouseLeave);
        mainCanvas.addEventListener('wheel', handleWheel, { passive: false });

        // Output Presets
        outputPresetSelect.addEventListener('change', (e) => {
            const selectedPreset = e.target.value;
            // Always set cropShape to 'custom' when an output preset is chosen (unless circle is selected)
            // But we don't change cropShape here to respect user choice.
            // We just update customCropWidth/Height for the 'custom' mode.

            if (selectedPreset === 'none') {
                customOutputDimensionsDiv.classList.remove('hidden'); // Show custom inputs
                customOutputWidthInput.value = '';
                customOutputHeightInput.value = '';
                // Only reset customCropWidth/Height if cropShape is 'custom'
                if (cropShape === 'custom') {
                    customCropWidth = 800; // Revert to default custom values
                    customCropHeight = 600;
                    customCropWidthInput.value = 800;
                    customCropHeightInput.value = 600;
                }
            } else {
                customOutputDimensionsDiv.classList.add('hidden'); // Hide custom inputs
                // Force cropShape to 'custom' for presets
                document.querySelector('input[name="cropShape"][value="custom"]').checked = true;
                cropShape = 'custom';
                switch (selectedPreset) {
                    case '300x400':
                        customOutputWidthInput.value = 300;
                        customOutputHeightInput.value = 400;
                        customCropWidth = 300;
                        customCropHeight = 400;
                        customCropWidthInput.value = 300;
                        customCropHeightInput.value = 400;
                        break;
                    case '600x800':
                        customOutputWidthInput.value = 600;
                        customOutputHeightInput.value = 800;
                        customCropWidth = 600;
                        customCropHeight = 800;
                        customCropWidthInput.value = 600;
                        customCropHeightInput.value = 800;
                        break;
                    case 'passport':
                        customOutputWidthInput.value = 350;
                        customOutputHeightInput.value = 450;
                        customCropWidth = 350;
                        customCropHeight = 450;
                        customCropWidthInput.value = 350;
                        customCropHeightInput.value = 450;
                        break;
                }
            }
            drawCanvas(); // Redraw canvas with new crop/output settings
        });

        customOutputWidthInput.addEventListener('input', drawCanvas);
        customOutputHeightInput.addEventListener('input', drawCanvas);
        pixelDensitySelect.addEventListener('change', drawCanvas);
        customDPIInput.addEventListener('input', drawCanvas);


        // Download Buttons
        downloadPngBtn.addEventListener('click', () => downloadImage('png'));
        downloadJpegBtn.addEventListener('click', () => downloadImage('jpeg'));
        generateDescriptionBtn.addEventListener('click', handleGenerateDescription);
        clearAppBtn.addEventListener('click', clearApp);

        // Description Modal Buttons
        closeDescriptionModal.addEventListener('click', () => descriptionModal.classList.add('hidden'));
        closeDescriptionModalBtn.addEventListener('click', () => descriptionModal.classList.add('hidden'));
        descriptionModal.addEventListener('click', (e) => {
            if (e.target === descriptionModal) { // Close only if clicking on overlay
                descriptionModal.classList.add('hidden');
            }
        });

        // Initial setup for default crop width/height and pixel density display
        customCropWidthInput.value = customCropWidth;
        customCropHeightInput.value = customCropHeight;
        pixelDensitySelect.value = '4k'; // Ensure dropdown reflects default state
        
        // Hide initial API key warning if key is set
        if (REMOVEBG_API_KEY !== "bNDVjQhJJA1R2zi22A5fhzN2") {
            removeBgApiWarning.classList.add('hidden');
        } else {
            removeBgApiWarning.classList.remove('hidden'); // Ensure warning is visible if key is default placeholder
        }
    </script>
</body>
</html>
